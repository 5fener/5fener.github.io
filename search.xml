<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>顺序表和链表的比较</title>
      <link href="/2023/02/21/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/2023/02/21/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>顺序表（顺序存储)</p><ul><li><p>优点：支持随机存取、存储密度高</p></li><li><p>缺点：大片连续空间分配不方便，改变容量不方便</p></li></ul><p>链表（链式存储）</p><ul><li>优点：离散的小空间分配方便，改变容量方便</li><li>缺点：不可随机存取，存储密度低</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态链表</title>
      <link href="/2023/02/21/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/02/21/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>静态链表：分配一整片连续的内存空间，各个结点集中安置</p><p>优点：增删操作不需要大量移动元素</p><p>缺点：不能随机存取，只能从头结点开始依次往后查找；<strong>容量固定不可变</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;<span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;<span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;<span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">typedef struct Node SLinkList[MaxSize];</span></span><br><span class="line"><span class="comment">***/</span></span><br></pre></td></tr></table></figure><ul><li><p>查找：从头结点出发挨个往后遍历结点</p></li><li><p>插入位序为 i 的结点：</p><ul><li>找到一个空的结点，存入数据元素</li><li>从头结点出发找到位序为 i-1 的结点</li><li>修改新结点的 next</li><li>修改 i-1 号结点的 next</li></ul></li><li><p>删除某个结点</p><ul><li>从头结点出发找到前驱结点</li><li>修改前驱结点的游标</li><li>被删除结点next设为-2（用一个特殊的数值标记空闲结点）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环链表</title>
      <link href="/2023/02/21/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/02/21/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;<span class="comment">//定义单链表结点类型</span></span><br><span class="line">    ElemType data;<span class="comment">//每个结点存放一个数据类型</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;<span class="comment">//指针指向下一个结点</span></span><br><span class="line">&#125;LNode, *LNodeList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = L;<span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTail</span><span class="params">(LinkList L, LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *prior, *next;</span><br><span class="line">&#125;DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化空的循环双链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L =(DNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));<span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = L;<span class="comment">//头结点的 prior 指向头结点</span></span><br><span class="line">    L-&gt;next = L;<span class="comment">//头结点的 next 指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环双链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环双链表的表尾结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTail</span><span class="params">(DLinkList L, DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表的插入"><a href="#双链表的插入" class="headerlink" title="双链表的插入"></a>双链表的插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span></span>&#123;</span><br><span class="line">    s-&gt;next = p-&gt;next;<span class="comment">//将结点*s插入到结点*p之后</span></span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表的删除"><a href="#双链表的删除" class="headerlink" title="双链表的删除"></a>双链表的删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除p的后继结点q</span></span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双链表</title>
      <link href="/2023/02/21/%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/02/21/%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="双链表的初始化（带头结点）"><a href="#双链表的初始化（带头结点）" class="headerlink" title="双链表的初始化（带头结点）"></a>双链表的初始化（带头结点）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *prior, *next;</span><br><span class="line">&#125;DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化双链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));<span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior == <span class="literal">NULL</span>;<span class="comment">//头结点的 prior 永远指向 NULL</span></span><br><span class="line">    L-&gt;next == <span class="literal">NULL</span>;<span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双链表是否为空（带头结点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testDLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化双链表</span></span><br><span class="line">    DLinkList L;</span><br><span class="line">    <span class="built_in">InitDLinkList</span>(L);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表的插入"><a href="#双链表的插入" class="headerlink" title="双链表的插入"></a>双链表的插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在p结点之后插入s结点（后插）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>)<span class="comment">//非法参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)<span class="comment">//如果p结点有后继结点</span></span><br><span class="line">        p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior -&gt; p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表的删除"><a href="#双链表的删除" class="headerlink" title="双链表的删除"></a>双链表的删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除p结点的后继结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p-&gt;next;<span class="comment">//找到p结点的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//p没有后继</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next != <span class="literal">NULL</span>)<span class="comment">//q结点不是最后一个结点</span></span><br><span class="line">        q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);<span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestoryList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各zhi xiang个数据结点</span></span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">DeleteNextDNode</span>(L);</span><br><span class="line">    <span class="built_in">free</span>(L);<span class="comment">//释放头结点</span></span><br><span class="line">    L = <span class="literal">NULL</span>;<span class="comment">//头指针指向NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表的遍历"><a href="#双链表的遍历" class="headerlink" title="双链表的遍历"></a>双链表的遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后向遍历</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前向遍历</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前向遍历（跳过头结点）</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;prior != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的建立</title>
      <link href="/2023/02/21/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
      <url>/2023/02/21/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h2><h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将输出元素以单链表的形式存储</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;<span class="comment">//正向建立单链表</span></span><br><span class="line">    <span class="type">int</span> x;<span class="comment">//设ElemType为整型</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//建立头结点</span></span><br><span class="line">    LNode *s, *r = L;<span class="comment">//r为表尾指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">9999</span>)&#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;<span class="comment">//r指向新的表尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;<span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;<span class="comment">//逆向建立单链表</span></span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">//初始为空链表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);<span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>)&#123;<span class="comment">//输入9999表示结束</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//创建新结点</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;<span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：注意养成好习惯，将单链表初始化，都先把头指针指向NULL<code>L-&gt;next = NULL</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的查找</title>
      <link href="/2023/02/21/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/02/21/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位查找，返回第 i 个元素（带头结点）</span></span><br><span class="line"><span class="function">LNode * <span class="title">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p；<span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;<span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;<span class="comment">//L指向头结点，头结点是第0各结点（不存数据）</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i)&#123;<span class="comment">//循环找到第 i 个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="function">LNode * <span class="title">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> L:</span><br><span class="line">    <span class="keyword">if</span>（i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找，找到数据域 == e 的结点</span></span><br><span class="line"><span class="function">LNode * <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span></span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="comment">//从第1个结点开始查找数据域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//找到后返回该结点指针，否则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求表的长度"><a href="#求表的长度" class="headerlink" title="求表的长度"></a>求表的长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求表的长度（带头结点）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;<span class="comment">//统计表长</span></span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PS: 三种操作时间复杂度都是 O(n)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux云服务器远程登录失败</title>
      <link href="/2023/02/21/linux%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8D%E8%83%BD%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"/>
      <url>/2023/02/21/linux%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8D%E8%83%BD%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>在通过 Linux ssh 远程登录华为云服务器时，出现报错<strong>WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</strong></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li><p>这是SSH 使用过程中最常见的错误“警告：远程主机标识已更改”</p></li><li><h4 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h4><ul><li>服务器误报：<code>known_hosts</code>当服务器的唯一指纹与首次连接时存储在文件中的指纹不匹配时，通常会出现警告：远程主机识别错误。此密钥更改的一个常见原因是因为更改了 root 密码或重建了 VPS 服务器</li><li>更可怕的猜测是中间人攻击，攻击者将使用持有相同 IP 的虚假 SSH 服务器设置在你的连接和服务器之间。然后他们会将你的流量转发到真正的 SSH 服务器，让你不知道他们正在监视和收集您所做的一切</li></ul></li></ul><h3 id="谨慎排除"><a href="#谨慎排除" class="headerlink" title="谨慎排除"></a>谨慎排除</h3><p>如果你近期做出了如下改变，那么就是服务器误报而非中间人攻击引起的警告</p><ul><li><p>更改了你的 VPS 密码或 SSH 密钥</p></li><li><p>重建你的服务器</p></li><li><p>为多个远程系统分配相同的 IP 地址</p></li><li><p>销毁了你的服务器，然后启动了一台恰好具有相同 IP 地址的新服务器</p></li><li><p>切换操作系统或重新安装</p></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在排除自己是中间人攻击的受害者后，只需删除文件中的现有条目即可再次连接到你的服务器<code>known_hosts</code>，有几种方法可以做到</p><ul><li><h4 id="使用文本编辑器"><a href="#使用文本编辑器" class="headerlink" title="使用文本编辑器"></a>使用文本编辑器</h4></li><li><p>你可以使用任何文本编辑器浏览到您的<code>known_hosts</code>位置并删除与你的服务器 IP 对应的行。该<code>known_hosts</code>文件可能存储在以下位置：</p><ul><li><strong>Windows：</strong> <code>%USERPROFILE%\\.ssh or %USERPROFILE%\\ssh</code></li><li><strong>Linux 和 macOS：</strong> <code>.ssh/known_hosts</code></li></ul></li><li><h4 id="在命令行中使用-ssh-keygen"><a href="#在命令行中使用-ssh-keygen" class="headerlink" title="在命令行中使用 ssh-keygen"></a>在命令行中使用 ssh-keygen</h4><p>修改<code>known_hosts</code>一种可能更快、更通用的方法是通过 ssh-keygen删除您的行。您可以使用以下命令快速删除无效密钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -R &quot;your.server.ip&quot;</span><br></pre></td></tr></table></figure><p>当您通过此方法删除指纹时，您的旧信息将存储在<code>known_hosts.old</code></p></li></ul><p>PS：使用任一方法后再次连接到你的服务器会将你服务器的新指纹存储在你已知的主机文件中（<code>known_hosts</code>)，就像您第一次连接时一样</p>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂症 </tag>
            
            <tag> Linux </tag>
            
            <tag> 云服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的插入删除</title>
      <link href="/2023/02/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4/"/>
      <url>/2023/02/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="按位序插入（带头结点）"><a href="#按位序插入（带头结点）" class="headerlink" title="按位序插入（带头结点）"></a>按位序插入（带头结点）</h3><p>ListInsert(&amp;L, i, e)：插入操作，在表 L 中的第 i 个位置插入指定元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在第 i 个位置插入元素e（带头结点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInser</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;<span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;<span class="comment">//当前p指向的第几个结点</span></span><br><span class="line">    p = L；<span class="comment">//L指向头结点，头结点时第0各结点（不存数据）</span></span><br><span class="line">    <span class="keyword">while</span> (P != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)<span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;<span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按位序插入（不带头结点）"><a href="#按位序插入（不带头结点）" class="headerlink" title="按位序插入（不带头结点）"></a>按位序插入（不带头结点）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;<span class="comment">//插入第1个结点的操作与其他结点操作不同</span></span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s;<span class="comment">//头指针指向新结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;<span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;<span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;<span class="comment">//p指向第1个结点（注意：不是头结点）</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)&#123;<span class="comment">//循环找到第 i-1 个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)<span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指定结点的后插操作"><a href="#指定结点的后插操作" class="headerlink" title="指定结点的后插操作"></a>指定结点的后插操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后插操作：在p结点之后插入元素 e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s =(LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>)<span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;<span class="comment">//用结点s保存数据元素e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;<span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指定结点的前插操作"><a href="#指定结点的前插操作" class="headerlink" title="指定结点的前插操作"></a>指定结点的前插操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前插操作：在p结点之前插入元素 e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>)<span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;<span class="comment">//新结点s连到p之后</span></span><br><span class="line">    s-&gt;data = p-&gt;data;<span class="comment">//将p中数据元素复制到s中</span></span><br><span class="line">    p-&gt;data = e;<span class="comment">//p中元素覆盖为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前插操作：在p结点之前插入结点 s</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, LNode *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> fasle;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;<span class="comment">//s连到p之后</span></span><br><span class="line">    ElemType temp = p-&gt;data;<span class="comment">//交换数据域部分</span></span><br><span class="line">    p-&gt;data = s-&gt;data;</span><br><span class="line">    s-&gt;data = temp;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按位序删除（带头结点）"><a href="#按位序删除（带头结点）" class="headerlink" title="按位序删除（带头结点）"></a>按位序删除（带头结点）</h3><p>ListDelete(&amp;L, i, &amp;e) ：删除操作，删除表 L 中第 i 个位置的元素，并用 e 返回删除元素的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;<span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;<span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;<span class="comment">//p指向第1个结点（注意：不是头结点）</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)&#123;<span class="comment">//循环找到第 i-1 个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>)<span class="comment">//第i-1个结点之后已无其他结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p-&gt;next;<span class="comment">//令q指向被删除的结点</span></span><br><span class="line">    e = q-&gt;data;<span class="comment">//用e返回元素的值</span></span><br><span class="line">    p-&gt;next = q-&gt;next;<span class="comment">//将*q结点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q);<span class="comment">//释放结点的存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//删除成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指定结点的删除"><a href="#指定结点的删除" class="headerlink" title="指定结点的删除"></a>指定结点的删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除指定结点 p</span></span><br><span class="line"><span class="comment">//结点 p 不能为最后一个结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p-&gt;next;<span class="comment">//令q指向*p的后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;<span class="comment">//和后继结点交换数据域</span></span><br><span class="line">    p-&gt;next = q-&gt;next;<span class="comment">//将*p结点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q);<span class="comment">//释放后继结点的存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的定义</title>
      <link href="/2023/02/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89/"/>
      <url>/2023/02/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<ul><li>用“链式存储”（存储结构）实现了“线性结构”（逻辑结构）</li><li>一个结点存储一个数据元素</li><li>各结点间的先后关系用一个指针表示</li></ul><h3 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;<span class="comment">//定义单链表节点类型</span></span><br><span class="line">ElemType data;<span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> *next;<span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> LNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">typedef struct LNode&#123;//定义单链表结点类型</span></span><br><span class="line"><span class="comment">    ElemType data;//每个节点存放一个数据元素</span></span><br><span class="line"><span class="comment">struct LNode *next;//指针指向下一个节点</span></span><br><span class="line"><span class="comment">&#125;LNode, *LinkList;</span></span><br><span class="line"><span class="comment">***/</span></span><br></pre></td></tr></table></figure><ul><li><p>要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个节点</p></li><li><p>&#96;&#96;&#96;C++<br>LNode * L; &#x2F;&#x2F;声明一个指向单链表第一个节点的指针<br>LinkList L;&#x2F;&#x2F;声明一个指向单链表第一个节点的指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `LNode * GetElem(LinkList L, int i)`</span><br><span class="line"></span><br><span class="line">  - LNode 强调返回的是一个结点</span><br><span class="line">  - LinkList 强调这是一个单链表</span><br><span class="line"></span><br><span class="line">### 不带头结点的单链表</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">typedef struct LNode&#123;//定义单链表结点类型</span><br><span class="line">    ElemType data;//每个节点存放一个数据元素</span><br><span class="line">struct LNode *next;//指针指向下一个节点</span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">//初始化一个空的单链表</span><br><span class="line">bool InitList(LinkList &amp;L)&#123;</span><br><span class="line">L = NULL;//空表，暂时还没有任何结点</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test()&#123;</span><br><span class="line">    LinkList L;//声明一个指向单链表的指针</span><br><span class="line">    //初始化一个空表</span><br><span class="line">    InitList(L);</span><br><span class="line">    //......后续代码......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断单链表是否为空</span><br><span class="line">bool Empty(LinkList L)&#123;</span><br><span class="line">    if(L == NULL)</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line">/***或</span><br><span class="line">bool Empty(LinkList L)&#123;</span><br><span class="line">return (L == NULL);</span><br><span class="line">&#125;</span><br><span class="line">***/</span><br></pre></td></tr></table></figure></li></ul><h3 id="带头结点的单链表"><a href="#带头结点的单链表" class="headerlink" title="带头结点的单链表"></a>带头结点的单链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个单链表(带头结点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IniList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//头结点之后暂时还没有节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单链表是否为空(带头结点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next = <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表的查找</title>
      <link href="/2023/02/19/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/02/19/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p><strong>按位查找</strong>，获取表 L 中第 i 个位置的元素的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">ElemType data[MaxSize];<span class="comment">//用静态的“数组”存放数据元素</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList<span class="comment">//顺序表的类型定义（静态分配方式）</span></span><br><span class="line">    </span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.data[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>按值查找</strong>，在表 L 中查找具有给定关键字值的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">int</span> *data;<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line"><span class="type">int</span> MaxSize;<span class="comment">//顺序表的最大容量</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在顺序表L中查找第一个元素值等于e的元素，并返回其位序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SeqList L, <span class="type">int</span> e)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line"><span class="keyword">if</span>(L.data[i] == e)</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;<span class="comment">//数则下标为i的元素值等于e，返回其位序i+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//退出循环，说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><ul><li>最好情况：目标元素在表头<ul><li>循环1次，最好时间复杂度 &#x3D; O(1)</li></ul></li><li>最坏情况：目标元素在表尾<ul><li>循环n次，最坏时间复杂度 &#x3D; O(n)</li></ul></li><li>平均情况：假设目标元素出现在任何一个位置的概率相同，都是1&#x2F;n<ul><li>平均循环次数 &#x3D; (n + 1)&#x2F;2</li><li>平均时间复杂度 &#x3D; O(n)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表的插入和删除</title>
      <link href="/2023/02/19/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/"/>
      <url>/2023/02/19/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="顺序表的插入"><a href="#顺序表的插入" class="headerlink" title="顺序表的插入"></a>顺序表的插入</h2><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">int</span> data[MaxSize];<span class="comment">//用静态的“数组”存放数据元素</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;<span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L.length; j &gt;= i; j--)<span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">L.data[j] = L.data[j<span class="number">-1</span>];</span><br><span class="line">L.data[i<span class="number">-1</span>] = e;<span class="comment">//在位置i处放入e</span></span><br><span class="line">L.length++;<span class="comment">//长度加1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">SqList L;<span class="comment">//声明一个顺序表</span></span><br><span class="line"><span class="built_in">InitList</span>(L);<span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="built_in">ListInsert</span>(L, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更具有健壮性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)<span class="comment">//判断i的范围是否有效</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length &gt;= MaxSize)<span class="comment">//当前存储空间已满，不能插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = L.length; j &gt;= i; j--)<span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">        L.data[j] = L.data[j<span class="number">-1</span>];</span><br><span class="line">    L.data[i<span class="number">-1</span>] = e;<span class="comment">//将位置i处放入e</span></span><br><span class="line">    L.length++;<span class="comment">//长度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>最好情况：新元素插入到表尾，不需要移动元素<ul><li>i &#x3D; n + 1，循环 0 次；最好时间复杂度 &#x3D; O(1)</li></ul></li><li>最坏情况：新元素插入到表头，需要将原有的 n 个元素全部向后移动<ul><li>i &#x3D; 1, 循环 n 次；最坏时间复杂度 &#x3D; O(n)</li></ul></li><li>平均情况：假设新元素插入到任何一个位置的概率相同<ul><li>i &#x3D; 1, 2, 3, …, length + 1的概率都是 p &#x3D; 1 &#x2F; (n+1)</li><li>平均循环次数 &#x3D; n &#x2F; 2  </li><li>平均时间复杂度 &#x3D; O(n)</li></ul></li></ul><h2 id="顺序表的删除"><a href="#顺序表的删除" class="headerlink" title="顺序表的删除"></a>顺序表的删除</h2><h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)<span class="comment">//判断i的范围是否有效</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.data[i<span class="number">-1</span>];<span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= L.length; j++)<span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">        L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">    L.length--;<span class="comment">//线性表长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">SqList L;<span class="comment">//声明一个顺序表</span></span><br><span class="line"><span class="built_in">InitList</span>(L);<span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="type">int</span> e = <span class="number">-1</span>; <span class="comment">//用变量e把删除的元素“带回来”</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ListInsert</span>(L, <span class="number">3</span>, e))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;已删除第3个元素，删除元素值为%d\n&quot;</span>, e);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;位序i不合法，删除失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>最好情况：删除表尾元素，不需要移动其他元素<ul><li>i &#x3D; n， 循环 0 次，最好时间复杂度 &#x3D; O(1)</li></ul></li><li>最坏情况：删除表头元素，需要将后续的 n - 1个元素全都向前移动<ul><li>i &#x3D; 1, 循环 n - 1 次；最坏时间复杂度 &#x3D; O(n)</li></ul></li><li>平均情况：假设新元素插入到任何一个位置的概率相同<ul><li>i &#x3D; 1, 2, 3, …, length + 1的概率都是 p &#x3D; 1 &#x2F; n</li><li>平均循环次数 &#x3D; (n-1)&#x2F; 2</li><li>平均时间复杂度 &#x3D; O(n)</li></ul></li></ul><h2 id="代码要点"><a href="#代码要点" class="headerlink" title="代码要点"></a>代码要点</h2><ul><li>代码中注意位序 i 和数组下标的区别</li><li>算法要有健壮性，注意判断 i 的合法性</li><li>注意移动元素时是从靠前的元素开始还是从表尾元素开始</li><li>注意有的参数需要加“&amp;”引用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表的定义</title>
      <link href="/2023/02/19/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89/"/>
      <url>/2023/02/19/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h3 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>​逻辑上相邻的数据元素物理上也相邻</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>随机访问</strong>，即可以在 O(1) 时间内找到第 i 个元素</li><li>存储密度高，每个节点只存储数据元素</li><li>拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）</li><li>插入、删除操作不方便，需要移动大量元素</li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><h5 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h5><ul><li>使用”静态数组“实现</li><li>大小一旦确定就无法改变</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">ElemType data[MaxSize];<span class="comment">//用静态的“数组”存放数据元素</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;<span class="comment">//顺序表的类型定义（静态分配方式）</span></span><br></pre></td></tr></table></figure><ul><li>初始化一个顺序表</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">int</span> data[MaxSize];<span class="comment">//用静态的“数组”存放数据元素</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;<span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSixe; i++)</span><br><span class="line">L.data[i] = <span class="number">0</span>;<span class="comment">//将所有数据元素设置为默认初始值</span></span><br><span class="line">L.length = <span class="number">0</span>;<span class="comment">//顺序表长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">SqList L;<span class="comment">//声明一个顺序表</span></span><br><span class="line"><span class="built_in">InitList</span>(L);<span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h5><ul><li><p>使用”动态数组“实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"> ElemType *data;<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line"> <span class="type">int</span> MaxSize;<span class="comment">//顺序表的最大容量</span></span><br><span class="line"> <span class="type">int</span> length;<span class="comment">//顺序表的类型定义（动态分配方式）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态申请和释放内存空间</p><ul><li><p>C——malloc、free函数</p><ul><li><code>L.data = (ElemType*) malloc (sizeof (Elemtype) * InitSize);</code></li></ul></li><li><p>C++——new、delete关键字</p></li></ul></li><li><p>顺序表存满时，可再用malloc动态拓展顺序表的最大容量</p></li><li><p>需要将数据元素复制到新的存储区域，并用 free 函数释放原区域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"> <span class="type">int</span> *data;<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line"> <span class="type">int</span> MaxSize;<span class="comment">//顺序表的最大容量</span></span><br><span class="line"> <span class="type">int</span> length;<span class="comment">//顺序表的类型定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> SqList L;<span class="comment">//声明一个顺序表</span></span><br><span class="line"> <span class="built_in">InitList</span>(L);<span class="comment">//初始化顺序表</span></span><br><span class="line"> <span class="built_in">IncreaseSize</span>(L, <span class="number">5</span>);<span class="comment">//往顺序表中随便插入几个元素</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span></span>&#123;</span><br><span class="line"> <span class="comment">//用malloc函数申请一片连续的存储空间</span></span><br><span class="line"> L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> L.length = <span class="number">0</span>;</span><br><span class="line"> L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="type">void</span> IncreaseSize*SeqList &amp;L, <span class="type">int</span> len)&#123;</span><br><span class="line"> <span class="type">int</span> *p = L.data;</span><br><span class="line"> L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize + len) * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)&#123;</span><br><span class="line">  L.data[i] = p[i];<span class="comment">//将数据复制到新区域</span></span><br><span class="line"> &#125;</span><br><span class="line"> L.MaxSize = L.MaxSize + len;<span class="comment">//顺序表最大长度增加len</span></span><br><span class="line"> <span class="built_in">free</span>(p);<span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/2023/02/19/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2023/02/19/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<ul><li><p>线性表是具有<strong>相同</strong>数据类型的 n(n&gt;&#x3D;0) 个<strong>数据元素</strong>的<strong>有限序列</strong>，其中 n 为<strong>表长</strong>，当 n &#x3D; 0 时线性表是一个<strong>空表</strong>。若用L命名线性表，则其一般表示为 L &#x3D; (a<sub>1</sub>， a<sub>2</sub>， … , a<sub>i</sub>， a<sub>i+1</sub>, …，a<sub>n</sub>)</p><ul><li><p>每个数据元素所占空间一样大</p></li><li><p>a<sub>i</sub> 是线性表中的”第 i 个“元素线性表中的位序</p></li><li><p>a<sub>1</sub>是表头元素； a<sub>n</sub>是表尾元素</p></li><li><p>除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继</p></li></ul></li><li><p>线性表的基本操作</p><ul><li>InistList(&amp;L)：初始化表。构造一个空的线性表L，分配内存空间</li><li>DestroyList(&amp;L)：销毁操作。销毁线性表，并释放线性表 L 所占用的内存空间</li><li>ListInsert(&amp;L, i, e)：插入操作。在表 L 中的第 i 个位置上插入指定元素 e</li><li>ListDelete(&amp;L, i, &amp;e)：删除操作。删除表 L 中第 i 个位置的元素，并用 e 返回删除元素的值</li><li>LocateElem(L, e)：按值查找操作。在表 L 中查找具有给定关键字值的元素</li><li>GetElem(L, i): 按位查找操作。获取表 L 中第 i 个位置的元素的值</li></ul></li><li><p>其他常用操作</p><ul><li>Length(L)：求表长。返回线性表 L 的长度，即 L 中数据元素的个数</li><li>PrintList(L)：输出操作。按前后顺序输出线性表 L 的所有元素值</li><li>Empty(L)：判空操作。若 L 为空表，则返回 true，否则返回false</li></ul></li><li><p>什么时候传入参数的引用“&amp;”——对参数的修改结果需要“带回来”</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法的复杂度</title>
      <link href="/2023/02/18/%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2023/02/18/%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h2><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul><li><h4 id="问题计算"><a href="#问题计算" class="headerlink" title="问题计算"></a>问题计算</h4><ul><li>普通程序<ul><li>找到所占空间大小与问题规模相关的变量</li><li>分析所占空间 x 与问题规模 n 的关系 x &#x3D; f(n)</li><li>x 的数量级 O(x) 就是算法空间复杂度 S(n)</li></ul></li><li>递归程序<ul><li>找到递归调用的深度 x 与问题规模 n 的关系 x &#x3D; f(n)</li><li>x 的数量级 O(x) 就是算法空间复杂度 S(n)</li><li>有的算法各层函数所需存储空间不同，分析方法略有区别</li></ul></li></ul></li><li><h4 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h4><ul><li>加法规则： O(f(n)) + O(g(n)) &#x3D; O(max(f(n), g(n)))</li><li>乘法规则：O(f(n)) * O(g(n)) &#x3D; O(f(n) * g(n))</li><li>O(1) &lt; O(log<sub>2</sub>n) &lt; O(n) &lt; O(nlog<sub>2</sub>n) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</li></ul></li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li><p>事前预估算法时间开销 T(n) 与问题规模 n 的关系</p></li><li><p>顺序执行的代码只会影响常数项，可以忽略</p></li><li><p>只需挑循环中的一个基本操作分析它的执行次数与 n 的关系即可</p></li><li><p>如果有多层嵌套循环，只需关注最深层循环循环了几次</p></li><li><h4 id="如何计算"><a href="#如何计算" class="headerlink" title="如何计算"></a>如何计算</h4><ul><li>找到一个基本操作（最深层循环）</li><li>分析该基本操作的执行次数 x 与问题规模 n 的关系 x &#x3D; f(n)</li><li>x 的数量级 O(x) 就是算法时间复杂度 T(n)</li></ul></li><li><h4 id="常用技巧-1"><a href="#常用技巧-1" class="headerlink" title="常用技巧"></a>常用技巧</h4><ul><li>加法规则：O(f(n)) + O(g(n)) &#x3D; O(max(f(n), g(n)))</li><li>乘法规则：O(f(n)) * O(g(n)) &#x3D; O(f(n) * g(n))</li><li>O(1) &lt; O(log<sub>2</sub>n) &lt; O(n) &lt; O(nlog<sub>2</sub>n) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</li></ul></li><li><h4 id="三种复杂度"><a href="#三种复杂度" class="headerlink" title="三种复杂度"></a>三种复杂度</h4><ul><li>最坏时间复杂度：考虑输入数据“最坏”的情况</li><li>平均时间复杂度：考虑所有输入数据都等概率出现的情况</li><li>最好时间复杂度：考虑输入数据“最好”的情况</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构的三要素</title>
      <link href="/2023/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E8%A6%81%E7%B4%A0/"/>
      <url>/2023/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E8%A6%81%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h3><ul><li><p>逻辑结构</p><ul><li>集合结构</li><li>线性结构——一对一<ul><li>数据元素之间是一对一的关系</li><li>除了第一个元素，所有元素都有唯一前驱</li><li>除了最后一个元素，所有元素都有唯一后继</li></ul></li><li>树形结构——一对多</li><li>图状结构——多对多</li></ul></li><li><p>数据的运算</p><p>针对于某种逻辑结构，结合实际需求，定义基本运算</p><ul><li>基本运算<ul><li>查找第i个数据元素</li><li>在第i个位置插入新的数据元素</li><li>删除第i个位置的数据元素</li><li>……</li></ul></li></ul></li><li><p>物理结构（存储结构）</p><ul><li><p>顺序存储</p><ul><li>把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现</li></ul></li><li><p>非顺序存储（离散存储）</p><ul><li><p>链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系</p></li><li><p>索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）</p></li><li><p>散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储</p></li></ul></li><li><p>若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用非顺序存储，则各个数据元素在物理上是离散的</p></li><li><p>数据的存储结构会影响存储空间分配的方便程度</p></li><li><p>数据的存储结构会影响对数据运算的速度</p></li></ul></li><li><p>运算的定义是针对逻辑结构的，指出运算的功能</p></li><li><p>运算的实现是针对存储结构的，指出运算的具体操作步骤</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本概念和术语</title>
      <link href="/2023/02/17/ds%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/"/>
      <url>/2023/02/17/ds%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<ul><li><p>早期的计算机只用于处理纯数值问题；现代计算机经常处理<strong>非数值型</strong>问题</p></li><li><p><strong>数据</strong>：数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。</p></li><li><p><strong>数据元素</strong>描述的是一个个体</p><ul><li>数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。</li><li>一个数据元素可由多个数据项来组成，数据项是构成 数据元素的不可分割的最小单位</li></ul></li><li><p><strong>数据对象</strong>是具有相同性质的数据元素的集合，是数据的一个子集</p></li><li><p><strong>数据结构</strong>指相互之间存在一定关系的数据元素的集合</p><ul><li><p>线性数据结构、网状数据结构（同一个数据对象里的数据元素，可以组成不同的数据结构）</p></li><li><p>同样的数据元素，可组成不同的数据结构；不同的数据结构，可组成相同的数据结构</p></li></ul></li><li><p><strong>数据类型</strong>是一个值的集合和定义在此集合上的一组操作的总称</p><ul><li>原子类型，其值不可再分的数据类型<ul><li>bool类型：<ul><li>值范围：true、false</li><li>可进行操作：与、或、非…</li></ul></li><li>int类型：<ul><li>值范围:-2147483648~2147483647</li><li>可进行操作：加、减、乘、除、模运算…</li></ul></li></ul></li><li>结构类型，其值可以再分解为若干成分（分量）的数据类型<ul><li>结构体</li></ul></li></ul></li><li><p><strong>抽象数据类型（ADT）</strong>是抽象数据组织及与之相关的操作</p><ul><li>定义一个ADT，就是在“定义”一种数据结构</li><li>确定了ADT的存储结构，才能”实现“这种数据结构</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11标准</title>
      <link href="/2023/02/17/C++11/"/>
      <url>/2023/02/17/C++11/</url>
      
        <content type="html"><![CDATA[<ol><li><p>初始化的方式</p><p><code>int  b(2);</code></p><p><code>int n = &#123;(int)3.14&#125;</code>新的写法不允许有精度的缺失</p></li><li><p>指针置空</p><p><code>int *p = NULL;</code></p><p><code>int *p = nullptr;</code></p></li><li><p>自动类型</p><p><code>int a = 0;</code></p><p><code>auto a = 0;</code>根据值匹配类型</p></li><li><p>decltype()</p><p><code>int a = 0;</code></p><p><code>decltype(a)b;</code>根据a的类型定义一个和a类型一致的b变量</p><p><code>decltype((a))m = a; </code>给a取别名m</p></li><li><p>新的for规则</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = &quot;abcdef&quot;;</span><br><span class="line">for(auto i; str)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法，只能用来遍历数组等容器。i所代表的是里面存的元素</p></li><li><p>给类型取别名</p><p><code>typedef int INT;</code></p><p><code>typedef void(*pFun) ();</code></p><p><code>using Int = int;</code></p><p><code>using PFUN = void(*) ();</code></p></li><li><p>default在类中的用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">CA();</span><br><span class="line">&#125;</span><br><span class="line">CA::CA() = default;//默认调用默认构造</span><br></pre></td></tr></table></figure></li><li><p>final</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class CA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void fun()final&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从C过渡到C++</title>
      <link href="/2023/02/17/C-%3EC++/"/>
      <url>/2023/02/17/C-%3EC++/</url>
      
        <content type="html"><![CDATA[<p>C++新增</p><ul><li><p>语法：类</p><ul><li>封装、继承、多态</li><li>抽象、面向对象</li></ul></li><li><p>bool类型</p></li><li><p>用来描述“真”或”假“</p></li><li><p>取值范围： true， false</p></li><li><p>”非0为真“</p></li><li><p>内联函数：通过”内存膨胀“的方式，以空间换时间，提高程序运行速度</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C-&gt;C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERROR Deployer not found: baidu_url_submit</title>
      <link href="/2023/02/16/Hexo-d%20baitu-submit%E6%8A%A5%E9%94%99/"/>
      <url>/2023/02/16/Hexo-d%20baitu-submit%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-d的时候报错：ERROR-Deployer-not-found-baidu-url-submit"><a href="#hexo-d的时候报错：ERROR-Deployer-not-found-baidu-url-submit" class="headerlink" title="hexo d的时候报错：ERROR Deployer not found: baidu_url_submit"></a>hexo d的时候报错：ERROR Deployer not found: baidu_url_submit</h1><ul><li>在配置Blog提交百度等搜索引擎收录完成后，输入hexo d出现报错<code>ERROR Deployer not found: baidu_url_submit</code>，此处在百度站长平台的链接<strong>主动推送</strong>设置时操作</li><li>其主动推送的实现原理如下：<ul><li>新链接的产生， <code>hexo generate</code> 会产生一个文本文件，里面包含最新的链接</li><li>新链接的提交， <code>hexo deploy</code> 会从上述文件中读取链接，提交至百度搜索引擎</li></ul></li><li>问题发生在修改站点配置文件<code>_config.yml</code>时<ul><li><code>-type: baidu_url_submitter</code> 配置是 <code>baidu_url_submit</code> ，两者不一样</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> 杂症 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog快速搭建</title>
      <link href="/2023/02/15/Blog%E6%90%AD%E5%BB%BA-Hexo/"/>
      <url>/2023/02/15/Blog%E6%90%AD%E5%BB%BA-Hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h2><ul><li>先在GitHub上建立一个仓库</li></ul><h2 id="使用git安装"><a href="#使用git安装" class="headerlink" title="使用git安装"></a>使用git安装</h2><ul><li>建立一个Blog文件夹</li><li>在Blog文件右键Git Bush Here并输入<code>npm install -g hexo-cli</code>命令安装Hexo</li><li>输入hexo init命令初始化博客</li><li>输入hexo g命令静态部署</li><li>输入hexo s命令本地查看（在浏览器中输入<a href="https://local:4000/">https://local:4000</a>)</li></ul><h2 id="将Hexo部署到Github"><a href="#将Hexo部署到Github" class="headerlink" title="将Hexo部署到Github"></a>将Hexo部署到Github</h2><ul><li><p>回到Blog文件夹用记事本打开_config.yml文件</p></li><li><p>下滑到文件底部，修改并填写如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">type: git </span><br><span class="line">repository: https://github.com/5fener/5fener.github.io.git /#你的仓库地址/</span><br></pre></td></tr></table></figure></li><li><p>在Blog文件打开Git Bush 安装git部署插件，即输入命令：</p><p><code>npm install hexo hexo-deployer-git --save</code> 注意空格</p></li><li><p>输入hexo clean清除缓存文件和动态文件</p></li><li><p>输入hexo g生成网站静态文件到默认设置的public文件夹中</p></li><li><p>输入hexo d自动生成并部署到远程仓库</p></li><li><p>可能有延迟需要等待一段时间，网站才会变化，可输入hexo s查看本地Blog是否改变</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Blog搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows文件共享</title>
      <link href="/2021/12/26/Windows%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
      <url>/2021/12/26/Windows%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-文件共享"><a href="#Windows-文件共享" class="headerlink" title="Windows 文件共享"></a>Windows 文件共享</h1><h2 id="一、共享要求"><a href="#一、共享要求" class="headerlink" title="一、共享要求"></a>一、共享要求</h2><p>一般是局域网内使用</p><p>1、物理上处于同一局域网</p><ul><li>同一公司的网络</li><li>同一家庭的网络</li><li>在同一个手机热点下</li></ul><p>2、逻辑上处于同一局域网（使用的同一网络的IP地址）</p><ul><li>直接可以ping对方主机（可以直接访问）</li></ul><h2 id="二、共享权限"><a href="#二、共享权限" class="headerlink" title="二、共享权限"></a>二、共享权限</h2><p>1、共享权限</p><ul><li>一般设置为 everyone 完全控制</li></ul><p>2、NTFS权限</p><ul><li>前面已经设置完成</li></ul><p>3、用户从完了过访问 sever 的最终权限</p><ul><li>由共享权限和NTFS权限的交集部分<ul><li>举例：<ul><li>张三的共享权限是读取，NTFS权限是读取和写入，张三从网络访问共享最终的权限是读取</li></ul></li><li>经常设置办法<ul><li>共享权限设置最大，NTFS权限进行精细化设置</li><li>举例：张三共享权限设置完全控制，NTFS权限设置读取，张三从网络访问共享最终的权限是读取</li></ul></li></ul></li><li>共享权限默认有一个 everyone 组是读取，everyone 代表了所有人</li></ul><h2 id="三、访问共享"><a href="#三、访问共享" class="headerlink" title="三、访问共享"></a>三、访问共享</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\\192.168.188.132#192.168.188.132服务器的IP地址</span><br><span class="line">\\WIN-6JFV2DR59EJ#WIN-6JFV2DR59EJ服务器的主机名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> Windows安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册表基础</title>
      <link href="/2021/12/26/%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/12/26/%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="注册表基础"><a href="#注册表基础" class="headerlink" title="注册表基础"></a>注册表基础</h1><h2 id="一、注册表基础"><a href="#一、注册表基础" class="headerlink" title="一、注册表基础"></a>一、注册表基础</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><ul><li>注册表是Windows操作系统、硬件设备以及客户应用程序得以正常运行和保存设置的核心“数据库”，也可以说是一个非常巨大的树状分层结构的数据库系统</li><li>注册表记录了用户安装在计算机上的软件和每个程序的相互关联信息，它包括了计算机的 硬件配置，包括自动配置的即插即用的设备和已有的各种设备说明、状态属性以及各种状态信息和数据。利用一个强大的注册表数据库来统一集中地管理系统硬件设置、软件配置等信息，从而方便了管理，增强了系统地稳定性</li></ul><h3 id="2、早期注册表"><a href="#2、早期注册表" class="headerlink" title="2、早期注册表"></a>2、早期注册表</h3><ul><li>以ini为扩展名的文本文件的配置文件</li></ul><h3 id="3、Windows-95后的注册表"><a href="#3、Windows-95后的注册表" class="headerlink" title="3、Windows 95后的注册表"></a>3、Windows 95后的注册表</h3><ul><li><p>自Windows 95操作系统开始，注册表真正成为Windows用户经常接触的内容，并在其后的操作系统中继续沿用</p><ul><li><p>注册表数据库由多个文件组成</p></li><li><p>Windwos提供了注册表编辑器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在运行处输入命令打开注册表编辑器</span><br><span class="line">regedit</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4、注册表结构"><a href="#4、注册表结构" class="headerlink" title="4、注册表结构"></a>4、注册表结构</h3><ul><li><p>注册表以树状结构进行呈现</p><ul><li><p>子树（实际只有两颗子树，为了方便操作，分为了五颗子树）</p><ul><li><p>HKEY_LOCAL_MACHINE：记录关于本地计算机系统的信息，包括硬件和操作系统数据</p></li><li><p>HKEY_USERS：记录关于动态加载的用户配置文件和默认配置文件的信息</p></li><li><p>HKEY_CURRENT_USER：HKEY_USERS子树，它指向“HKEY_USERS\当前用户的安全ID”包含当前以交互方式登陆的用户的用户配置文件</p></li><li><p>HKEY_CURRENT_CONFIG：HEEY_LOCAL_MACHINE子树，指向</p><p>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Hardware Profiles\Current包含在启动时由本地计算机系统使用的硬件配置文件的相关信息加载的设备驱动程序、显示时要使用的分辨率</p></li><li><p>HKEY_CLASSES_ROOT：HKEY_CURRENT_USER子树包含用于各种OLE技术和文件类关联数据的信息</p></li></ul></li><li><p>项</p><ul><li>可以简单的理解为文件夹，项中可以包含项和值</li></ul></li><li><p>值</p><ul><li>每个注册表项或子项都可以包含称为值的数据</li><li>部分值应用于某个用户的信息</li><li>部分值应用于计算机所有用户的信息</li><li>值由三部分组成（值的名称、值类型、值的数据）</li></ul></li></ul></li></ul><h2 id="二、注册表基本操作"><a href="#二、注册表基本操作" class="headerlink" title="二、注册表基本操作"></a>二、注册表基本操作</h2><h3 id="1、创建项"><a href="#1、创建项" class="headerlink" title="1、创建项"></a>1、创建项</h3><h3 id="2、创建值（有六种类型的值）"><a href="#2、创建值（有六种类型的值）" class="headerlink" title="2、创建值（有六种类型的值）"></a>2、创建值（有六种类型的值）</h3><ul><li>字符串值（REG_SZ)：固定长度的文本字符串</li><li>二进制值（REG_BINARY）：原始二进制数据。多数硬件组件信息都以二进制数据存储</li><li>DWORD值（REG_DWORD）：数据由4字节长的数表示。设备驱动程序和服务的很多参数都是这种类型</li><li>QWORD值（REG_QWORD）: 数据由8字节长的数表示</li><li>多字符串值（REG_MULTI_SZ）：多重字符串。包含列表或多值的值通常为该类型</li><li>可扩充字符串值（REG_EXPAND_SZ）：长度可变的数据串。该数据类型包含在程序或服务使用该数据时解析的变量</li></ul><h3 id="3、修改、删除和重命名值"><a href="#3、修改、删除和重命名值" class="headerlink" title="3、修改、删除和重命名值"></a>3、修改、删除和重命名值</h3><h2 id="三、注册表应用"><a href="#三、注册表应用" class="headerlink" title="三、注册表应用"></a>三、注册表应用</h2><h3 id="1、案例"><a href="#1、案例" class="headerlink" title="1、案例"></a>1、案例</h3><ul><li><p>个性化时间设置</p><ul><li>打开注册表编辑器，锁定“HKEY_CURRENT_USER\Control Panel\International”下的值sTimeFormat进行修改</li></ul></li><li><p>在欢迎屏幕显示自定义信息</p><ul><li>打开注册表编辑器，锁定“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System”下的值legalnoticecaption（标题）legalnoticetext（文本）</li></ul></li><li><p>禁用任务管理器</p><ul><li>打开注册表编辑器，锁定“HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\system”下新建 DWORD 值 DisableTaskMgr，设置值为1</li></ul></li><li><p>禁用控制面板</p><ul><li>打开注册表编辑器，锁定“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer”下新建 DOWRD 值 NoControlPanel，设置值为1</li></ul></li><li><p>去除快捷方式左下角小箭头</p><ul><li>打开注册表编辑器，锁定“HKEY_CLASSES_ROOT\lnkfile”找到项下的 IsShortcut 值，直接删除</li></ul></li></ul><h3 id="2、注册表编辑技巧"><a href="#2、注册表编辑技巧" class="headerlink" title="2、注册表编辑技巧"></a>2、注册表编辑技巧</h3><ul><li>查找字符串、值、项</li><li>将子项添加到收藏夹</li><li>打印注册表</li><li>复制项名字</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> Windows安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册表维护与优化</title>
      <link href="/2021/12/26/%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%BB%B4%E6%8A%A4%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2021/12/26/%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%BB%B4%E6%8A%A4%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="注册表维护与优化"><a href="#注册表维护与优化" class="headerlink" title="注册表维护与优化"></a>注册表维护与优化</h1><h2 id="一、注册表维护"><a href="#一、注册表维护" class="headerlink" title="一、注册表维护"></a>一、注册表维护</h2><h3 id="1、注册表被破坏后的常见现象"><a href="#1、注册表被破坏后的常见现象" class="headerlink" title="1、注册表被破坏后的常见现象"></a>1、注册表被破坏后的常见现象</h3><ul><li>无法启动系统</li><li>无法运行或正常运行合法的应用程序</li><li>找不到启动系统或运行应用程序所需的文件</li><li>没有访问应用程序的权限</li><li>不能正确安装或装入驱动程序</li><li>不能进行网络连接</li><li>注册表条目有错误</li></ul><h3 id="2、注册表被破坏的原因"><a href="#2、注册表被破坏的原因" class="headerlink" title="2、注册表被破坏的原因"></a>2、注册表被破坏的原因</h3><ul><li>应用程序错误：在系统中安装过多的软件后，可能会出现彼此之间的冲突</li><li>驱动程序不兼容：安装系统时有很多驱动都是自动安装，容易产生不同硬件驱动程序不兼容的情况，建议到官方网站下载对应稳定版驱动进行安装</li><li>硬件问题：主要出现在硬件质量上，比如硬盘或内存质量不过关造成读写错误、超频、CMOS、病毒等</li><li>误操作：误操作是最常见的原因，可能会导致注册表出现错误，严重者造成系统崩溃或无法启动程序</li></ul><h3 id="3、备份注册表"><a href="#3、备份注册表" class="headerlink" title="3、备份注册表"></a>3、备份注册表</h3><ul><li>直接将注册表数据库文件进行备份</li><li>导出注册表<ul><li>找到对应的项直接选择导出</li></ul></li></ul><h3 id="4、恢复注册表"><a href="#4、恢复注册表" class="headerlink" title="4、恢复注册表"></a>4、恢复注册表</h3><ul><li>直接将数据库文件进行覆盖</li><li>将之前导出的项进行导入</li></ul><h3 id="5、锁定和解锁注册表"><a href="#5、锁定和解锁注册表" class="headerlink" title="5、锁定和解锁注册表"></a>5、锁定和解锁注册表</h3><ul><li>打开注册表编辑器，锁定到”HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System“项中新建DWORD值DisableRegistryTools，将值设置为1，表示锁定，设置为0表示解锁</li><li>当注册表被锁定后，Windows自带的注册表编辑器就无法打开，需要使用外部第三方注册表编辑工具来进行打开，找到对应项，修改值为1</li></ul><h2 id="二、注册表优化"><a href="#二、注册表优化" class="headerlink" title="二、注册表优化"></a>二、注册表优化</h2><h3 id="1、优化内容"><a href="#1、优化内容" class="headerlink" title="1、优化内容"></a>1、优化内容</h3><ul><li>清除多余的DLL文件<ul><li>打开注册表编辑器，锁定到”HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\SharedDLLs“项，在这个项下存放的是共享的DLL信息，注意看括号里面的数据，它表示共享文件的数目，如果为0，则可将其删除</li></ul></li><li>安装卸载应用程序的垃圾信息<ul><li>打开注册表编辑器，锁定到”HKEY_CURRENT_USER\SOFTWARE”项和”HKEY_LOCAL_MACHINE\SOFTWARE“项，这两个项中包含系统中的应用程序，对于已知的程序是知道的，主要是针对一些未知的程序进行删除和一些已经卸载了的残留</li></ul></li><li>系统安装时产生的无用信息<ul><li>删除多余时区（必要情况下只保留北京时区）<ul><li>锁定到”HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones“项</li></ul></li><li>清楚多余的语言代码（英语—0409、中文—0804）<ul><li>锁定到”HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Nls\Locale“项</li></ul></li><li>删除多余的键盘布局<ul><li>锁定到”HKEY_LOCAL_MACHINE\SYSTEM\Keyboard Layout“项，下面每一个子项代表一种键盘布局</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> Windows安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组策略应用</title>
      <link href="/2021/12/26/%E7%BB%84%E7%AD%96%E7%95%A5%E5%BA%94%E7%94%A8/"/>
      <url>/2021/12/26/%E7%BB%84%E7%AD%96%E7%95%A5%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="组策略应用"><a href="#组策略应用" class="headerlink" title="组策略应用"></a>组策略应用</h1><h2 id="一、组策略基本概念"><a href="#一、组策略基本概念" class="headerlink" title="一、组策略基本概念"></a>一、组策略基本概念</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>组策略是一种允许你通过组策略设置和组策略首选项为用户和计算机指定受管理配置的基础结构。 要配置仅影响本地计算机或用户的组策略设置，你可以使用本地组策略编辑器。 你可以在 Active Directory 域服务 (AD DS) 环境中通过组策略管理控制台 (GPMC) 管理组策略设置和组策略首选项。 组策略管理工具还包含在远程服务器管理工具包中，以帮助你从桌面管理组策略设置。</p><p>组策略是一组策略的集合</p><h3 id="2、打开方式"><a href="#2、打开方式" class="headerlink" title="2、打开方式"></a>2、打开方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpedit.msc</span><br></pre></td></tr></table></figure><h3 id="3、刷新组策略"><a href="#3、刷新组策略" class="headerlink" title="3、刷新组策略"></a>3、刷新组策略</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpupdate /force</span><br></pre></td></tr></table></figure><h3 id="4、模块"><a href="#4、模块" class="headerlink" title="4、模块"></a>4、模块</h3><ul><li>计算机配置<ul><li>针对于本地计算机生效</li></ul></li><li>用户配置<ul><li>针对于用户生效</li></ul></li></ul><h2 id="二、案例"><a href="#二、案例" class="headerlink" title="二、案例"></a>二、案例</h2><h3 id="1、隐藏桌面的系统图标"><a href="#1、隐藏桌面的系统图标" class="headerlink" title="1、隐藏桌面的系统图标"></a>1、隐藏桌面的系统图标</h3><ul><li>用户配置——&gt;管理模板</li></ul><h3 id="2、保护任务栏和“开始”菜单"><a href="#2、保护任务栏和“开始”菜单" class="headerlink" title="2、保护任务栏和“开始”菜单"></a>2、保护任务栏和“开始”菜单</h3><ul><li>用户配置——&gt;“开始菜单”和任务栏</li></ul><h3 id="3、保护个人文档隐私（历史使用文件）"><a href="#3、保护个人文档隐私（历史使用文件）" class="headerlink" title="3、保护个人文档隐私（历史使用文件）"></a>3、保护个人文档隐私（历史使用文件）</h3><ul><li>用户配置——&gt;“开始菜单”和任务栏</li></ul><h3 id="4、禁用在浏览器上新窗口中打开"><a href="#4、禁用在浏览器上新窗口中打开" class="headerlink" title="4、禁用在浏览器上新窗口中打开"></a>4、禁用在浏览器上新窗口中打开</h3><ul><li>用户配置—–&gt;Windows 组件——&gt;Internet Explorer</li></ul><h3 id="5、禁用控制面板"><a href="#5、禁用控制面板" class="headerlink" title="5、禁用控制面板"></a>5、禁用控制面板</h3><ul><li><p>用户配置——&gt;控制面板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#打开控制面板命令</span><br><span class="line">control.exe</span><br></pre></td></tr></table></figure></li></ul><h3 id="6、关闭自动播放功能"><a href="#6、关闭自动播放功能" class="headerlink" title="6、关闭自动播放功能"></a>6、关闭自动播放功能</h3><ul><li>计算机配置——&gt;管理模板——&gt;Windows 组件——&gt;自动播放策略</li></ul><h3 id="7、配置自动更新"><a href="#7、配置自动更新" class="headerlink" title="7、配置自动更新"></a>7、配置自动更新</h3><ul><li>计算机配置——&gt;管理模板——&gt;Windows 组件——&gt;Windows 更新</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> Windows安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTFS权限</title>
      <link href="/2021/12/24/NTFS%E6%9D%83%E9%99%90/"/>
      <url>/2021/12/24/NTFS%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="NTFS-权限"><a href="#NTFS-权限" class="headerlink" title="NTFS 权限"></a>NTFS 权限</h1><h2 id="一、NTFS权限"><a href="#一、NTFS权限" class="headerlink" title="一、NTFS权限"></a>一、NTFS权限</h2><p>1、文件系统</p><ul><li><p>Windows</p><ul><li>早期Windows上使用 FAT16或 FAT32</li><li>目前的Windows操作系统基本使用的是 NTFS 文件系统<ul><li>ACL(访问控制列表，设置权限)</li><li>EFS（加密文件系统，使用BitLocker进行磁盘加密</li><li>压缩及磁盘配额</li></ul></li><li>ReFS文件系统</li></ul></li><li><p>Linux</p><ul><li><p>swap：交换文件系统，主要将磁盘的一部分空间划分给内存使用</p></li><li><p>ext4：</p></li><li><p>文件系统转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\五分儿&gt;convert g:/fs:ntfs//g 表示的是需要转换的盘符</span><br><span class="line">文件系统的类型是 FAT32。</span><br><span class="line">卷序列号为 7D8C-7EAA</span><br><span class="line">Windows 正在校验文件和文件夹...</span><br><span class="line">已完成文件和文件夹验证。</span><br><span class="line"></span><br><span class="line">Windows 已扫描文件系统并且没有发现问题。</span><br><span class="line">无需采取进一步操作。</span><br><span class="line">总共有    60,049,056 KB 磁盘空间。</span><br><span class="line">2 个隐藏文件中有            64 KB。</span><br><span class="line">6 个文件夹中有           192 KB。</span><br><span class="line">6 个文件中有         5,344 KB。</span><br><span class="line">   60,043,424 KB 可用。</span><br><span class="line"></span><br><span class="line">每个分配单元中有        32,768 字节。</span><br><span class="line">磁盘上共有     1,876,533 个分配单元。</span><br><span class="line">磁盘上有     1,876,357 个可用的分配单元。</span><br><span class="line"></span><br><span class="line">正在确定文件系统转换所需的磁盘空间...</span><br><span class="line">磁盘总空间:                 60063728 KB</span><br><span class="line">卷上的可用空间:                 60043424 KB</span><br><span class="line">转换所需的空间:                   141010 KB</span><br><span class="line">正在转换文件系统</span><br><span class="line">数据错误(循环冗余检查)。</span><br></pre></td></tr></table></figure><p>早期的FAT文件系统不支持单个大文件（超过4GB）</p></li></ul></li></ul><h2 id="二、文件权限"><a href="#二、文件权限" class="headerlink" title="二、文件权限"></a>二、文件权限</h2><p>1、设置文件权限</p><ul><li>读取数据</li><li>写入数据</li><li>附加数据</li><li>删除</li><li>执行文件</li></ul><h2 id="三、文件夹权限"><a href="#三、文件夹权限" class="headerlink" title="三、文件夹权限"></a>三、文件夹权限</h2><p>1、设置文件夹权限</p><ul><li>列出文件夹</li><li>创建文件夹</li><li>创建文件</li><li>删除</li><li>删除子文件夹和文件</li></ul><h2 id="四、权限分类"><a href="#四、权限分类" class="headerlink" title="四、权限分类"></a>四、权限分类</h2><ul><li><p>完全控制</p></li><li><p>修改</p></li><li><p>读取和执行</p></li><li><p>读取</p></li><li><p>写入</p></li><li><p>特殊权限</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> Windows安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTFS权限规则</title>
      <link href="/2021/12/24/NTFS%E6%9D%83%E9%99%90%E8%A7%84%E5%88%99/"/>
      <url>/2021/12/24/NTFS%E6%9D%83%E9%99%90%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="NTFS-权限规则"><a href="#NTFS-权限规则" class="headerlink" title="NTFS 权限规则"></a>NTFS 权限规则</h1><h2 id="一、权限规则"><a href="#一、权限规则" class="headerlink" title="一、权限规则"></a>一、权限规则</h2><h4 id="1、权限的累加"><a href="#1、权限的累加" class="headerlink" title="1、权限的累加"></a>1、权限的累加</h4><ul><li>用户分配的有效权限是分配给用户所有权限的累加<ul><li>假设一个用户配置了读取权限，给用户所属组分配了修改权限，用户最终的权限就等于读取和修改</li></ul></li></ul><h3 id="2、拒绝权限"><a href="#2、拒绝权限" class="headerlink" title="2、拒绝权限"></a>2、拒绝权限</h3><ul><li>拒绝的权限大于一切（在访问控制列表中，拒绝的权限优先级最高）</li><li>当出现权限冲突的时候，拒绝的权限优先级最高（举例：用户所属组读取权限，用户拒绝读取，最终用户没有读取权限）</li></ul><h3 id="3、继承权限"><a href="#3、继承权限" class="headerlink" title="3、继承权限"></a>3、继承权限</h3><ul><li>文件或文件夹的访问控制列表默认情况下会继承上级文件夹的权限</li></ul><h3 id="4、特殊权限（特别的权限）"><a href="#4、特殊权限（特别的权限）" class="headerlink" title="4、特殊权限（特别的权限）"></a>4、特殊权限（特别的权限）</h3><ul><li>读取权限（和读取文件或文件夹的内容没有关系）<ul><li>读取文件或文件夹的访问控制列表</li><li>针对于用户想要访问某个文件的内容，此权限必须勾选</li></ul></li><li>更改权限（和修改文件或文件夹的内容没有关系）<ul><li>用户是否可以修改文件或文件夹的访问控制列表，由于此权限是可以为用户添加或删除权限，会造成很多不安全因素，此权限一般不会给</li><li>要想更改，前提是必须能读取</li></ul></li><li>取得所有权<ul><li>能够修改文件或文件夹的所有者</li><li>前提必须得读取和修改</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> Windows安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows基础命令</title>
      <link href="/2021/12/24/Windows%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/12/24/Windows%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-基础命令"><a href="#Windows-基础命令" class="headerlink" title="Windows 基础命令"></a>Windows 基础命令</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p><strong>掌握Windows系统文件及目录操作命令</strong></p><p><strong>掌握Windows网络相关命令</strong></p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="Windows输入命令-使用命令提示符对话-CMD"><a href="#Windows输入命令-使用命令提示符对话-CMD" class="headerlink" title="Windows输入命令 使用命令提示符对话 CMD"></a>Windows输入命令 使用命令提示符对话 CMD</h3><h3 id="一-目录和文件的应用操作"><a href="#一-目录和文件的应用操作" class="headerlink" title="一. 目录和文件的应用操作"></a>一. 目录和文件的应用操作</h3><ol><li><p>cd命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /d d:\    //切换到d盘目录，因为改变了驱动器，所以需要加上/d选项 </span><br><span class="line"></span><br><span class="line">c:\Users\Administrator&gt;cd c:\    //如果没有改变驱动器，就不需要加/d选项</span><br></pre></td></tr></table></figure></li></ol><ul><li>目录分为相对路径和绝对路径<ul><li>相对路径(以当前为起点)<ul><li>“.”代表的是当前路径</li><li>“..&#x2F;“代表的是当前的上一级目录</li></ul></li><li>绝对路径（以驱动器号为起点）</li></ul></li></ul><ol start="2"><li>dir命令</li></ol><ul><li><p>用于显示目录和文件列表</p></li><li><p>常用的用法直接使用dir</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- dir</span><br><span class="line">  dir /a:h c:\   #查看c盘下的隐藏目录和文件</span><br><span class="line">  dir /o:-n c:\  #使用字母逆序方式查看</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>md 或 mkdir</li></ol><ul><li><p>创建目录（文件夹），也可以创建多级子目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- md 公司文件夹</span><br><span class="line">  md 公司文件夹\技术部\技术文件夹  #当技术部文件夹不存在时会直接创建</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>rd</li></ol><ul><li><p>用于删除目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rd 成都文件  #直接使用rd，只能删除空目录</span><br><span class="line">rd /s /q 公司文件夹  #如果要删除的目录中只有子目录或文件，就必须使用/s选项，可以携带/q选项不提醒</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li>move</li></ol><ul><li><p>用于移动，重命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d:\&gt;move woniu.bmp c:\#移动</span><br><span class="line">d:\&gt;move c:\woniu.bmp c:\woniutf.bmp#重命名</span><br></pre></td></tr></table></figure></li></ul><ol start="6"><li>copy</li></ol><ul><li><p>用于复制文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d:\&gt;copy c:\woniutf.bmp d:\woniuxy   #直接复制文件到指定目录</span><br><span class="line">d:\&gt;copy 1.txt+2.txt 3.txt   #将两个文件中的内容直接融合到新的文件中</span><br></pre></td></tr></table></figure></li></ul><ol start="7"><li>xcopy</li></ol><ul><li><p>用于复制目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><ol start="8"><li>del</li></ol><ul><li><p>用于删除文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d:\&gt;del 1.txt</span><br></pre></td></tr></table></figure></li></ul><h3 id="二-文本处理"><a href="#二-文本处理" class="headerlink" title="二. 文本处理"></a>二. 文本处理</h3><ol><li>type</li></ol><ul><li><p>用于显示文本内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c:\Windows\System32&gt;type d:\3.txt</span><br><span class="line">&lt;内容&gt;</span><br></pre></td></tr></table></figure></li><li><p>重定向 “&gt;”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\Windows\System32&gt;ipconfig &gt; c:\ip.txt</span><br></pre></td></tr></table></figure></li><li><p>管道符 “|”</p><ul><li>将前面命令执行的结果做为后面命令的操作对象</li></ul></li></ul><ol start="2"><li>finder</li></ol><ul><li><p>查找文件内容（查找的某个字符串的内容）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\Windows\System32&gt;findstr 192 c:\ip.txt</span><br></pre></td></tr></table></figure></li></ul><h3 id="三-网络相关操作"><a href="#三-网络相关操作" class="headerlink" title="三.网络相关操作"></a>三.网络相关操作</h3><ol><li>配置TCP&#x2F;IP参数</li></ol><ul><li><p>TCP&#x2F;IP参数</p><ul><li><p>IP 地址：标识了网络中的某一台主机</p></li><li><p>子网掩码：用于标识你的 IP 所处的网络的范围，子网掩码越大，网络范围越小</p></li><li><p>默认网关：标识与主机直连的路由器的 IP 地址</p></li><li><p>DNS 服务器：用于域名解析的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#静态配置IP地址、子网掩码、默认网关</span><br><span class="line">c:&gt;netsh interface ip set address &quot;Ethernet0&quot; static 192.168.100.100 255.255.255.0 192.168.100.254</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#自动获取 TCP/IP 参数</span><br><span class="line">c:&gt;netsh interface ip set address &quot;Ethernet0&quot; dhcp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#静态配置 DNS 服务器</span><br><span class="line">c:&gt;netsh interface ip set dnssever &quot;Ethernet0&quot; static 12.12.12.12</span><br><span class="line">#添加备用 DNS 服务器</span><br><span class="line">c:&gt;netsh interface ip set dnssever &quot;Ethernet0&quot; 222.66.66.66 index=2//index=2 是索引，表示备用 DNS</span><br><span class="line">#自动获取 DNS 服务器</span><br><span class="line">c:&gt;netsh interface ip set dnssever &quot;Ethernet0&quot; dhcp</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="2"><li>查看TCP&#x2F;IP参数，用ipconfig</li></ol><ul><li><p>常用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#查看所有网卡的TCP/IP参数（IP地址、子网掩码、默认网关）</span><br><span class="line">ipconfig</span><br><span class="line">#查看所有网卡的TCP/IP参数（IP地址、子网掩码、默认网关、mac地址、dhcp地址、dns地址、主机名）</span><br><span class="line">ipconfig /all</span><br><span class="line">#释放TCP/IP参数</span><br><span class="line">ipconfig /release</span><br><span class="line">#重新获取TCP/IP参数</span><br><span class="line">ipconfig /renew</span><br><span class="line">#刷新dns缓存</span><br><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>ping命令</li></ol><ul><li><p>用于测试TCP&#x2F;IP配置是否正确</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ping -n 10 -l 1000 -t -a 192.168.31.131</span><br><span class="line"># -n 10 发送10个报文</span><br><span class="line"># -l 1000 单个报文10000个字节</span><br><span class="line"># -t 一直不停的ping</span><br><span class="line"># -a 返回IP的主机名</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>tracert</li></ol><ul><li><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:&gt;tracert 39.156.66.14</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li>route</li></ol><ul><li><p>用来操作网络路由表</p><ul><li><p>0.0.0.0代表的任意网路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#打印路由表</span><br><span class="line">route -4 print</span><br><span class="line">#添加路由条目</span><br><span class="line">（112.53.42.52目标地址或网络 /32代表子网掩码或者112.53.42.0目标网络，/24代表子网掩码，192.168.33.1网关地址）</span><br><span class="line">route add 122.53.42.52/32 192.168.33.1</span><br><span class="line">#删除路由条目</span><br><span class="line">route delete 112.53.42.52 #（112.53.42.52目标）</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="6"><li>netstat</li></ol><ul><li><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看所有的TCP链接，包括进程，以数字形式显示</span><br><span class="line">netstat -anop tcp</span><br><span class="line">#查看路由表</span><br><span class="line">netstat -r等同于route print</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> Windows安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows用户管理</title>
      <link href="/2021/12/24/Windows%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>/2021/12/24/Windows%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-用户管理"><a href="#Windows-用户管理" class="headerlink" title="Windows 用户管理"></a>Windows 用户管理</h1><h2 id="一、用户账户"><a href="#一、用户账户" class="headerlink" title="一、用户账户"></a>一、用户账户</h2><p>1、什么是用户账户</p><ul><li><p>不同的用户身份拥有不同的权限</p></li><li><p>每个用户包含了一个名称和一个密码</p></li><li><p>每个用户账户具有唯一的安全标识符</p></li><li><p>查看系统中的用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure></li><li><p>安全标识符（SID）</p><ul><li><p>查看当前用户的SID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /user</span><br></pre></td></tr></table></figure><ul><li>使用注册表进行查看 打开注册表命令 regedit</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList</span><br></pre></td></tr></table></figure><ul><li>在Windows系统中管理员的 SID 是500，普通用户的 SID 是从10000开始</li></ul></li></ul></li></ul><p>2、 进行用户管理</p><ul><li><p>创建用户</p><ul><li><p>用户名：系统的显示名</p></li><li><p>全名：用户登录时的显示名</p></li><li><p>密码：Windows服务器默认需要符合复杂性要求</p></li><li><p>账户已锁定：如果开启了账户锁定阈值，输错密码多次后将被锁定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#创建用户不指定密码</span><br><span class="line">net user zhangsan /add</span><br><span class="line">#创建用户指定明文密码</span><br><span class="line">net user lisi p-0p-0 /add</span><br><span class="line">#创建用户手动输入密码</span><br><span class="line">net user wangwu /add *</span><br><span class="line">#删除用户</span><br><span class="line">net user zhangsan /del</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#修改用户的密码</span><br><span class="line">net user lisi p-0p-0p-0</span><br><span class="line">net user lisi *</span><br></pre></td></tr></table></figure></li></ul></li><li><p>管理用户</p></li><li><p>设置密码</p></li><li><p>隐藏用户</p><ul><li>在用户的后面加上了 $ 符号，隐藏用户用 net user 命令是无法看到的</li></ul></li></ul><h2 id="二、Windows的内置用户账户"><a href="#二、Windows的内置用户账户" class="headerlink" title="二、Windows的内置用户账户"></a>二、Windows的内置用户账户</h2><p>1、与使用者关联的</p><ul><li>管理员 administrator： 在使用者中具有最高的权限，如果没有其它管理员的情况下，不建议使用</li><li>普通用户：具有一般的读取权限，权限较低</li><li>来宾用户guest： 一般是提供给访客使用，在使用者中，权限最低，默认是禁用</li></ul><p>2、与Windows组件关联的</p><ul><li>system 本地系统，拥有最高权限</li><li>local service 本地服务，它的权限相对于普通用户组 users 会低一点</li><li>network service 网络服务，它的权限和普通用户组 users 一样</li></ul><h1 id="Windows-组的管理"><a href="#Windows-组的管理" class="headerlink" title="Windows 组的管理"></a>Windows 组的管理</h1><p>用户</p><p>1、与人员关联</p><ul><li>administrator</li><li>guest</li></ul><p>2、与组件关联</p><ul><li>system</li><li>local service</li><li>network service</li></ul><h2 id="一、用户组"><a href="#一、用户组" class="headerlink" title="一、用户组"></a>一、用户组</h2><p>1、概念</p><ul><li>一组用户的集合，组中所有的用户具备所组的权限</li></ul><p>2、管理组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#创建组</span><br><span class="line">C:\Users\Administrator\net localgroup 技术部 /add</span><br><span class="line">#删除组</span><br><span class="line">C:\Users\Administrator\net localgroup 技术部 /del</span><br><span class="line">#创建并将用户加入组</span><br><span class="line">C:\Users\Administrator\net localgroup 技术部 zhangsan /add</span><br><span class="line">#将用户从组中拿掉</span><br><span class="line">C:\Users\Administrator\net localgroup 技术部 zhangsan /del</span><br></pre></td></tr></table></figure><h2 id="二、内置组账户"><a href="#二、内置组账户" class="headerlink" title="二、内置组账户"></a>二、内置组账户</h2><p>1、需要人为添加的</p><ul><li>administrators：管理员组</li><li>guests：来宾用户组</li><li>power users：向下兼容的组，现在一般没有使用</li><li>users：标准用户组，创建用户后默认处于此组中</li></ul><p>2、动态包含成员的组</p><ul><li>interactive：动态包含在本地登陆的用户</li><li>authenticated users：动态包含通过验证的用户</li><li>everyone：所有人，包含了来宾用户</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> Windows安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地安全策略</title>
      <link href="/2021/12/24/%E6%9C%AC%E5%9C%B0%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/"/>
      <url>/2021/12/24/%E6%9C%AC%E5%9C%B0%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="本地安全策略"><a href="#本地安全策略" class="headerlink" title="本地安全策略"></a>本地安全策略</h1><h2 id="一、本地安全策略基本内容"><a href="#一、本地安全策略基本内容" class="headerlink" title="一、本地安全策略基本内容"></a>一、本地安全策略基本内容</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><ul><li>主要是都登录到计算机的账户进行一些安全设置</li><li>主要影响是本地计算机安全设置</li></ul><h3 id="2、打开方式"><a href="#2、打开方式" class="headerlink" title="2、打开方式"></a>2、打开方式</h3><ul><li><p>开始菜单——&gt;管理工具——&gt;本地安全策略</p></li><li><p>使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secpol.msc</span><br></pre></td></tr></table></figure></li><li><p>从本地组策略进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#使用命令</span><br><span class="line">gpedit.msc</span><br></pre></td></tr></table></figure></li></ul><h2 id="二、账户策略"><a href="#二、账户策略" class="headerlink" title="二、账户策略"></a>二、账户策略</h2><h3 id="1、密码策略"><a href="#1、密码策略" class="headerlink" title="1、密码策略"></a>1、密码策略</h3><ul><li><p>密码必须符合复杂性要求</p><ul><li><p>默认情况下，Windows server 操作系统是开启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">不能包含用户的帐户名，不能包含用户姓名中超过两个连续字符的部分</span><br><span class="line">至少有六个字符长</span><br><span class="line">包含以下四类字符中的三类字符:</span><br><span class="line">英文大写字母(A 到 Z)</span><br><span class="line">英文小写字母(a 到 z)</span><br><span class="line">10 个基本数字(0 到 9)</span><br><span class="line">非字母字符(例如 !、$、#、%)</span><br><span class="line">在更改或创建密码时执行复杂性要求</span><br></pre></td></tr></table></figure></li></ul></li><li></li></ul><h3 id="2、账户锁定策略"><a href="#2、账户锁定策略" class="headerlink" title="2、账户锁定策略"></a>2、账户锁定策略</h3><ul><li>账户锁定时间</li><li>账户锁定阈值</li><li>重置账户锁定计数器时间</li><li>管理员是不受限制的</li></ul><p>远程桌面命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstsc</span><br></pre></td></tr></table></figure><h2 id="三、本地策略"><a href="#三、本地策略" class="headerlink" title="三、本地策略"></a>三、本地策略</h2><h3 id="1、审核策略"><a href="#1、审核策略" class="headerlink" title="1、审核策略"></a>1、审核策略</h3><h3 id="2、用户权限分配"><a href="#2、用户权限分配" class="headerlink" title="2、用户权限分配"></a>2、用户权限分配</h3><h3 id="3、安全选项"><a href="#3、安全选项" class="headerlink" title="3、安全选项"></a>3、安全选项</h3>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> Windows安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机基本指南</title>
      <link href="/2021/12/22/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E6%9C%AC%E6%8C%87%E5%8D%97/"/>
      <url>/2021/12/22/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E6%9C%AC%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机基本指南"><a href="#虚拟机基本指南" class="headerlink" title="虚拟机基本指南"></a>虚拟机基本指南</h1><h2 id="1、虚拟网编辑器"><a href="#1、虚拟网编辑器" class="headerlink" title="1、虚拟网编辑器"></a>1、虚拟网编辑器</h2><ul><li><p>vmnet0 一般是桥接 与物理网络直接相连</p></li><li><p>vmnet1 一般是仅主机模式 单独自己一个网络</p></li><li><p>vmnet8 一般是NAT模式 使用网络地址转换的方式与物理网络相连</p></li></ul><h2 id="2、快照"><a href="#2、快照" class="headerlink" title="2、快照"></a>2、快照</h2><ul><li><p>保存虚拟机当前的状态</p></li><li><p>建议使用关机快照，占用磁盘空间较小</p></li></ul><h2 id="3、克隆"><a href="#3、克隆" class="headerlink" title="3、克隆"></a>3、克隆</h2><ul><li><p>相当于复制一台新的虚拟机</p></li><li><p>链接克隆（依托于原始虚拟机文件，所以原始虚拟机文件不能删除）</p></li><li><p>完整克隆（将原始虚拟机完全复制一份，原始虚拟机文件删除后不影响克隆的虚拟机）</p></li></ul><h2 id="3、虚拟机与物理机切换"><a href="#3、虚拟机与物理机切换" class="headerlink" title="3、虚拟机与物理机切换"></a>3、虚拟机与物理机切换</h2><ul><li><p>虚拟机 —&gt; 物理机</p></li><li><p>Ctrl+Alt</p></li><li><p>物理机 —&gt; 虚拟机</p></li><li><p>Ctrl+g</p></li></ul><h2 id="4、如果想要将物理机的文件直接放入到虚拟机中需要安装插件"><a href="#4、如果想要将物理机的文件直接放入到虚拟机中需要安装插件" class="headerlink" title="4、如果想要将物理机的文件直接放入到虚拟机中需要安装插件"></a>4、如果想要将物理机的文件直接放入到虚拟机中需要安装插件</h2><ul><li>VMware Tools插件</li></ul>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
            <tag> VMWare </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
